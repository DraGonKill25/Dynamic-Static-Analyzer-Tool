#! File analysis module
# Information gathering, suspicious string extraction, report generation

import os
import sys
import hashlib
import subprocess
import platform
import re
from datetime import datetime
from pathlib import Path
from typing import Tuple


def calculate_hash(file_path: str) -> str:
    """Returns the SHA256 hash of a file (for VirusTotal, etc.)."""
    h = hashlib.sha256()
    with open(file_path, "rb") as f:
        for block in iter(lambda: f.read(4096), b""):
            h.update(block)
    return h.hexdigest()


def calculate_hashes(file_path: str) -> dict:
    """Computes MD5, SHA1 and SHA256 hashes of a file."""
    hashes = {'md5': '', 'sha1': '', 'sha256': ''}
    try:
        with open(file_path, 'rb') as f:
            data = f.read()
        hashes['md5'] = hashlib.md5(data).hexdigest()
        hashes['sha1'] = hashlib.sha1(data).hexdigest()
        hashes['sha256'] = hashlib.sha256(data).hexdigest()
    except Exception as e:
        hashes['error'] = str(e)
    return hashes


def get_file_info(file_path: str) -> dict:
    """Gathers basic information about a file."""
    info = {}
    try:
        stat = os.stat(file_path)
        info['path'] = file_path
        info['name'] = os.path.basename(file_path)
        info['size'] = stat.st_size
        info['size_formatted'] = _format_size(stat.st_size)
        info['modified'] = datetime.fromtimestamp(stat.st_mtime).isoformat()
        info['extension'] = Path(file_path).suffix
        info['hashes'] = calculate_hashes(file_path)
    except Exception as e:
        info['error'] = str(e)
    return info


def _format_size(size_bytes: int) -> str:
    """Formats size in human-readable units."""
    for unit in ["B", "KB", "MB", "GB"]:
        if size_bytes < 1024.0:
            return f"{size_bytes:.2f} {unit}"
        size_bytes /= 1024.0
    return f"{size_bytes:.2f} TB"


def extract_strings(file_path: str, min_length: int = 4) -> list:
    """Extracts printable ASCII strings from a binary file."""
    strings_found = []
    try:
        with open(file_path, 'rb') as f:
            data = f.read()
        current = []
        for byte in data:
            if 32 <= byte <= 126:
                current.append(chr(byte))
            else:
                if len(current) >= min_length:
                    s = ''.join(current)
                    strings_found.append(s)
                current = []
        if len(current) >= min_length:
            strings_found.append(''.join(current))
    except Exception as e:
        return [f"Error: {e}"]
    return strings_found


def extract_suspicious_strings(file_path: str, min_length: int = 6) -> list:
    """Extracts potentially suspicious strings (URLs, IPs, paths, etc.)."""
    all_strings = extract_strings(file_path, min_length)
    suspicious = []
    patterns = {
        'url': r'https?://[^\s\x00]+',
        'ip': r'\b(?:\d{1,3}\.){3}\d{1,3}\b',
        'path_windows': r'[A-Za-z]:\\[^\s\x00]+',
        'path_unix': r'/[\w/.-]+',
        'registry': r'HKEY_[^\s\x00]+|HKLM\\[^\s\x00]+|HKCU\\[^\s\x00]+',
        'cmd': r'(?:cmd|powershell|wscript|cscript|reg\s)\s*[^\s\x00]*',
        'base64': r'[A-Za-z0-9+/]{20,}={0,2}',
    }
    seen = set()
    for s in all_strings:
        for pattern_name, pattern in patterns.items():
            matches = re.findall(pattern, s)
            for m in matches:
                if m not in seen and len(m) >= min_length:
                    seen.add(m)
                    suspicious.append({'type': pattern_name, 'value': m})
    return suspicious


def run_file_command(file_path: str) -> str:
    """Runs the 'file' command (Linux/Mac) or Python equivalent (Windows)."""
    if platform.system() in ('Linux', 'Darwin'):
        try:
            result = subprocess.run(['file', file_path], capture_output=True, text=True, timeout=10)
            return result.stdout.strip() if result.returncode == 0 else result.stderr or "Command failed"
        except FileNotFoundError:
            return "Command 'file' not found. Install file-utils."
        except subprocess.TimeoutExpired:
            return "Timeout while running 'file'"
    else:
        # Windows: basic detection by extension and header
        try:
            ext = Path(file_path).suffix.lower()
            ext_map = {
                '.exe': 'PE32 executable', '.dll': 'PE32 DLL',
                '.py': 'Python script', '.pyc': 'Python bytecode',
                '.bat': 'Batch script', '.ps1': 'PowerShell script',
                '.js': 'JavaScript', '.vbs': 'VBScript',
                '.html': 'HTML document', '.doc': 'Microsoft Word',
            }
            with open(file_path, 'rb') as f:
                header = f.read(16)
            if header[:2] == b'MZ':
                return f"{file_path}: PE32 executable (Windows)"
            return f"{file_path}: {ext_map.get(ext, 'unknown')} ({ext or 'no ext'})"
        except Exception as e:
            return f"Error: {e}"


def run_strings_command(file_path: str, min_len: int = 4) -> str:
    """Runs 'strings' (system) if available, otherwise Python extraction."""
    if platform.system() in ('Linux', 'Darwin'):
        try:
            result = subprocess.run(['strings', '-n', str(min_len), file_path],
                                   capture_output=True, text=True, timeout=30)
            if result.returncode == 0:
                return result.stdout[:50000] + ("\n...(truncated)" if len(result.stdout) > 50000 else "")
            return result.stderr or "Command failed"
        except FileNotFoundError:
            pass
    # Fallback Python
    strs = extract_strings(file_path, min_len)
    output = '\n'.join(strs[:2000])
    if len(strs) > 2000:
        output += f"\n... ({len(strs) - 2000} more strings)"
    return output


def run_strace(file_path: str) -> str:
    """Runs strace on an executable (Linux only)."""
    if platform.system() != 'Linux':
        return "strace is only available on Linux. On Windows, use Process Monitor or API Monitor."
    if not file_path.lower().endswith(('.exe', '')) and not os.access(file_path, os.X_OK):
        return "File is not executable. strace traces system calls of a process."
    try:
        result = subprocess.run(['strace', '-f', '-e', 'trace=open,read,write,execve', file_path],
                               capture_output=True, text=True, timeout=5)
        return result.stderr or result.stdout or "No output"
    except FileNotFoundError:
        return "strace not installed. Install with: sudo apt install strace"
    except subprocess.TimeoutExpired:
        return "Timeout: process was interrupted after 5 seconds."


def open_ghidra(file_path: str) -> Tuple[bool, str]:
    """Opens Ghidra with the file (if installed)."""
    ghidra_paths = [
        os.environ.get('GHIDRA_INSTALL_DIR'),
        r"C:\ghidra",
        r"C:\Program Files\ghidra",
        "/opt/ghidra",
        os.path.expanduser("~/ghidra"),
    ]
    for base in ghidra_paths:
        if not base or not os.path.isdir(base):
            continue
        for name in os.listdir(base):
            if name.startswith('ghidra') and os.path.isdir(os.path.join(base, name)):
                analyzer = os.path.join(base, name, 'analyzeHeadless.bat' if platform.system() == 'Windows' else 'analyzeHeadless')
                if os.path.isfile(analyzer):
                    try:
                        # Open with GUI if ghidraRun exists
                        run_script = os.path.join(os.path.dirname(analyzer), 'ghidraRun.bat' if platform.system() == 'Windows' else 'ghidraRun')
                        if os.path.isfile(run_script):
                            subprocess.Popen([run_script, file_path], cwd=os.path.dirname(run_script))
                            return True, f"Ghidra launched with {file_path}"
                        subprocess.Popen([analyzer, '.', 'temp_project', '-import', file_path])
                        return True, f"Ghidra (headless) imported {file_path}"
                    except Exception as e:
                        return False, str(e)
    return False, "Ghidra not found. Install Ghidra and set GHIDRA_INSTALL_DIR or place it in C:\\ghidra"


def run_full_analysis(file_path: str, output_report: str = None) -> str:
    """Legacy analysis. For advanced analysis, use run_full_analysis_engine."""
    lines = []
    lines.append("=" * 60)
    lines.append(f"ANALYSIS REPORT - {datetime.now().isoformat()}")
    lines.append("=" * 60)
    lines.append("")

    # 1. Informations fichier
    info = get_file_info(file_path)
    if 'error' in info:
        lines.append(f"Error: {info['error']}")
        return '\n'.join(lines)
    lines.append("--- FILE INFORMATION ---")
    lines.append(f"Name: {info['name']}")
    lines.append(f"Size: {info['size_formatted']} ({info['size']} bytes)")
    lines.append(f"Modified: {info['modified']}")
    lines.append(f"MD5:    {info['hashes'].get('md5', 'N/A')}")
    lines.append(f"SHA1:   {info['hashes'].get('sha1', 'N/A')}")
    lines.append(f"SHA256: {info['hashes'].get('sha256', 'N/A')}")
    lines.append("")

    # 2. Type de fichier
    lines.append("--- FILE TYPE ---")
    lines.append(run_file_command(file_path))
    lines.append("")

    # 3. Suspicious strings
    lines.append("--- SUSPICIOUS STRINGS ---")
    sus = extract_suspicious_strings(file_path)
    if sus:
        for i, s in enumerate(sus[:50], 1):
            lines.append(f"  [{s['type']}] {s['value'][:80]}")
        if len(sus) > 50:
            lines.append(f"  ... and {len(sus) - 50} more")
    else:
        lines.append("  No suspicious strings detected.")
    lines.append("")

    # 4. Extraits de strings (premiers)
    lines.append("--- STRING SAMPLES ---")
    strs = extract_strings(file_path, 6)
    for s in strs[:30]:
        lines.append(f"  {s[:100]}")
    if len(strs) > 30:
        lines.append(f"  ... ({len(strs)} strings total)")
    lines.append("")

    lines.append("=" * 60)
    lines.append("End of report")
    report = '\n'.join(lines)

    if output_report:
        try:
            with open(output_report, 'w', encoding='utf-8') as f:
                f.write(report)
        except Exception as e:
            report += f"\n[File write error: {e}]"

    return report


def run_full_analysis_engine(file_path: str, config_path: str, profile: str = None, vt_report: dict = None,
                             api_key: str = None, output_dir: str = None, formats: list = None) -> dict:
    """Advanced analysis via engine (profiles, YARA, scoring, structured reports)."""
    from pathlib import Path
    script_dir = Path(__file__).resolve().parent
    cfg = config_path or str(script_dir / "config.ini")
    out_dir = output_dir or os.path.dirname(file_path)
    formats = formats or ["md", "html"]
    try:
        from core.engine import run_analysis
        from modules.report_generator import generate_report
    except ImportError:
        return {"error": "Core modules not found"}
    analysis = run_analysis(file_path, cfg, profile, vt_report, api_key)
    if "error" in analysis:
        return analysis
    report_paths = generate_report(analysis, out_dir, formats)
    analysis["report_paths"] = report_paths
    return analysis


def _run_watch(watch_dir: str, config_path: str, report_format: str = "html", profile: str = "auto"):
    """Monitors a folder and analyzes new files."""
    try:
        from watchdog.observers import Observer
        from watchdog.events import FileSystemEventHandler
    except ImportError:
        print("Install watchdog: pip install watchdog")
        return

    class Handler(FileSystemEventHandler):
        def __init__(self, cfg, fmt, prof):
            self.config_path = cfg
            self.fmt = fmt
            self.profile = prof
            self.analyzed = set()

        def on_created(self, event):
            if event.is_directory:
                return
            path = event.src_path
            if path in self.analyzed:
                return
            self.analyzed.add(path)
            if os.path.isfile(path):
                print(f"Analyzing: {path}")
                try:
                    a = run_full_analysis_engine(path, self.config_path, self.profile,
                                                output_dir=os.path.dirname(path),
                                                formats=[self.fmt])
                    if "error" not in a:
                        print(f"  Score: {a.get('risk_score', 0)}/100 | Reports: {a.get('report_paths', {})}")
                except Exception as e:
                    print(f"  Error: {e}")

    script_dir = Path(__file__).resolve().parent
    cfg = config_path or str(script_dir / "config.ini")
    handler = Handler(cfg, report_format, profile)
    observer = Observer()
    observer.schedule(handler, watch_dir, recursive=False)
    observer.start()
    print(f"Monitoring {watch_dir}. Ctrl+C to stop.")
    try:
        while True:
            import time
            time.sleep(1)
    except KeyboardInterrupt:
        observer.stop()
    observer.join()


def main():
    """Command-line entry point."""
    import argparse
    from pathlib import Path
    parser = argparse.ArgumentParser(description="Malware analyzer")
    parser.add_argument("file", nargs="?", help="File to analyze")
    parser.add_argument("--report", "-r", help="Report file (legacy txt)")
    parser.add_argument("--strings", action="store_true", help="Extraire les strings")
    parser.add_argument("--file", "-f", dest="filetype", action="store_true", help="Type de fichier")
    parser.add_argument("--suspicious", "-s", action="store_true", help="Suspicious strings")
    parser.add_argument("--watch", "-w", help="Surveiller un dossier")
    parser.add_argument("--auto-report", default="html", help="Format rapport (watch): html, md")
    parser.add_argument("--profile", "-p", default="auto", help="Profil: pe, script, elf, document, auto")
    parser.add_argument("--output", "-o", help="Dossier de sortie des rapports")
    parser.add_argument("--format", nargs="+", default=["md", "html"], help="Formats: md html")
    parser.add_argument("--config", "-c", help="Chemin config.ini")
    args = parser.parse_args()

    if args.watch:
        _run_watch(args.watch, args.config, args.auto_report, args.profile)
        return

    if not args.watch and not args.file:
        parser.print_help()
        sys.exit(1)

    path = args.file
    if not path or not os.path.isfile(path):
        print(f"File not found: {path}")
        sys.exit(1)

    if args.strings:
        print(run_strings_command(path))
    elif args.filetype:
        print(run_file_command(path))
    elif args.suspicious:
        for s in extract_suspicious_strings(path):
            print(f"[{s['type']}] {s['value']}")
    elif args.report:
        print(run_full_analysis(path, args.report))
    else:
        a = run_full_analysis_engine(path, args.config or str(Path(__file__).parent / "config.ini"),
                                     args.profile, output_dir=args.output or os.path.dirname(path),
                                     formats=args.format)
        if "error" in a:
            print(f"Error: {a['error']}")
            sys.exit(1)
        print(f"Score: {a.get('risk_score', 0)}/100 ({a.get('risk_level', 'LOW')})")
        print(f"Badges: {', '.join(a.get('badges', [])) or 'None'}")
        for fmt, p in a.get("report_paths", {}).items():
            print(f"Report {fmt}: {p}")


if __name__ == "__main__":
    main()
